"use strict";(self.webpackChunkdodalovic_github_io=self.webpackChunkdodalovic_github_io||[]).push([[5866],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=s(a),u=r,d=c["".concat(p,".").concat(u)]||c[u]||g[u]||o;return a?n.createElement(d,i(i({ref:t},m),{},{components:a})):n.createElement(d,i({ref:t},m))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},5386:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var n=a(7462),r=(a(7294),a(3905));const o={title:"Java 8 flatMap stream operator",authors:["dodalovic"],tags:["technology","java8"]},i=void 0,l={permalink:"/blog/java-8-flatmap-stream-operator",editUrl:"https://github.com/dodalovic/dodalovic.github.io/tree/main/blog/java-8-flatmap-stream-operator/index.mdx",source:"@site/blog/java-8-flatmap-stream-operator/index.mdx",title:"Java 8 flatMap stream operator",description:"Let's see a simple example of Java 8 Stream:",date:"2023-03-26T13:20:59.000Z",formattedDate:"March 26, 2023",tags:[{label:"technology",permalink:"/blog/tags/technology"},{label:"java8",permalink:"/blog/tags/java-8"}],readingTime:2.45,hasTruncateMarker:!0,authors:[{name:"Dusan Odalovic",url:"https://github.com/dodalovic",imageURL:"https://github.com/dodalovic.png",key:"dodalovic"}],frontMatter:{title:"Java 8 flatMap stream operator",authors:["dodalovic"],tags:["technology","java8"]},prevItem:{title:"Is Google Pixelbook software development ready",permalink:"/blog/is-pixelbook-software-development-ready"},nextItem:{title:"Java 8 Stream API - reduce operator",permalink:"/blog/java-8-stream-api-reduce-operator"}},p={authorsImageUrls:[void 0]},s=[],m={toc:s},c="wrapper";function g(e){let{components:t,...a}=e;return(0,r.kt)(c,(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Let's see a simple example of ",(0,r.kt)("inlineCode",{parentName:"p"},"Java 8")," ",(0,r.kt)("inlineCode",{parentName:"p"},"Stream::flatMap")," method found in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Stream")," API. Definition of ",(0,r.kt)("inlineCode",{parentName:"p"},"flatMap")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"API")," doc is:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by\napplying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this\nstream. (If a mapped stream is null an empty stream is used, instead.)")),(0,r.kt)("p",null,"So - say we have a simple ",(0,r.kt)("inlineCode",{parentName:"p"},"Java")," class named ",(0,r.kt)("inlineCode",{parentName:"p"},"Developer"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"package rs.dodalovic.streams.flap_map;\n\nimport java.util.List;\n\npublic class Developer {\n    private final String name;\n    private final List<String> programmingLanguages;\n\n    public Developer(String name, List<String> programmingLanguages) {\n        this.name = name;\n        this.programmingLanguages = programmingLanguages;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public List<String> getProgrammingLanguages() {\n        return programmingLanguages;\n    }\n}\n")),(0,r.kt)("p",null,"Simple ",(0,r.kt)("inlineCode",{parentName:"p"},"POJO")," contains the developer name, as well as list of programming languages programmer knows. Now, let's create some\nexecutable code to finally demo what we want:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'package rs.dodalovic.streams.flap_map;\n\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static java.util.Arrays.asList;\n\npublic class FlatMapMain {\n\n    private static final String JAVA = "Java";\n    private static final String PHP = "Php";\n    private static final String JAVASCRIPT = "Javascript";\n    private static final String RUBY = "Ruby";\n    private static final String SCALA = "Scala";\n    private static final String PYTHON = "Python";\n    private static final String CLOJURE = "Clojure";\n\n    public static void main(String[] args) {\n\n        final List<Developer> developers = asList(\n                new Developer("John", asList(JAVA, PHP)),\n                new Developer("Peter", asList(JAVA, PHP, JAVASCRIPT)),\n                new Developer("Mike", asList(JAVA, PHP, CLOJURE)),\n                new Developer("Steven", asList(JAVA, PHP, JAVASCRIPT, PYTHON)),\n                new Developer("Kylie", asList(PHP, RUBY, SCALA)));\n\n        final Set<String> supportedProgrammingLanguages = developers.stream()\n                .flatMap(toLanguagesStream())\n                .collect(Collectors.toSet());\n\n        System.out.format("All supported languages: \\n\\n");\n        supportedProgrammingLanguages.forEach(System.out::println);\n    }\n\n    private static Function<Developer, Stream<String>> toLanguagesStream() {\n        return developer -> developer.getProgrammingLanguages().stream();\n    }\n}\n')),(0,r.kt)("p",null,"First, we populate developers List with some sample developers. What we do after is that we start streaming through given developers,\nand then want to collect all the languages that all given developers support in total. We do that using ",(0,r.kt)("inlineCode",{parentName:"p"},"flatMap")," operator which accepts\nmapping ",(0,r.kt)("inlineCode",{parentName:"p"},"Function")," parameter. In our case we implemented the mapping in ",(0,r.kt)("inlineCode",{parentName:"p"},"toLanguagesStream")," method, where we map each developer to it's\nsupported languages stream. What happens then is that for each developer we get it's languages, which are merged at the end - after\nlast developer is streamed. ",(0,r.kt)("inlineCode",{parentName:"p"},"Java Stream API")," will do the merging for us, so ",(0,r.kt)("inlineCode",{parentName:"p"},"flatMap")," returns final stream - consisting of all merged\nlanguages for all the developers."),(0,r.kt)("p",null,"In order to display only distinct languages (since we have the cases one language is shared across many developers) we use collect\noperator, which accepts instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector")," interface. In our case we choose out of the box implementation which is shipped with\n",(0,r.kt)("inlineCode",{parentName:"p"},"JDK - Collectors.toSet()"),"."),(0,r.kt)("p",null,"Code snippets can be found ",(0,r.kt)("a",{parentName:"p",href:"https://gist.github.com/dodalovic/571f1730774ccae6d949"},"on GitHub")),(0,r.kt)("p",null,"Feel free to experiment with ",(0,r.kt)("inlineCode",{parentName:"p"},"flatMap")," and find other useful cases to apply it."),(0,r.kt)("p",null,"That was all for today! Hope you liked it!"))}g.isMDXComponent=!0}}]);